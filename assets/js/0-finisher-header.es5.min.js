"use strict";
var _classCallCheck = function(t, i) {
  if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function");
};

var _createClass = (function() {
  function defineProperties(t, i) {
    for (var s = 0; s < i.length; s++) {
      var e = i[s];
      e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(t, e.key, e);
    }
  }
  return function(i, s, e) {
    return s && defineProperties(i.prototype, s), e && defineProperties(i, e), i;
  };
})();

!function(window) {
  // ✅ 全局暴露 parseColor 函数
  window.parseColor = function(t) {
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(t)) {
      var i = t.substring(1).split("");
      3 === i.length && (i = [i[0], i[0], i[1], i[1], i[2], i[2]]);
      var s = parseInt(i.join(""), 16);
      return { r: s >> 16 & 255, g: s >> 8 & 255, b: 255 & s };
    }
    return { r: 0, g: 0, b: 0 };
  };

  // 粒子类
  var Particle = (function() {
    function Particle(color, positionType, config) {
      _classCallCheck(this, Particle);
      this.config = config;
      this.color = parseColor(color);
      this.direction = this.getRandomDirection();
      this.shape = this.getRandomShape();
      this.size = Math.abs(this.getRandomInRange(config.size));
      this.initializePosition(positionType);
      this.vx = this.getRandomInRange(config.speed.x) * this.direction;
      this.vy = this.getRandomInRange(config.speed.y) * this.direction;
    }

    _createClass(Particle, [
      {
        key: "initializePosition",
        value: function(positionType) {
          var area = this.getPositionArea();
          switch (positionType) {
            case 3:
              this.x = area.x + area.halfWidth;
              this.y = area.y;
              break;
            case 2:
              this.x = area.x;
              this.y = area.y + area.halfHeight;
              break;
            case 1:
              this.x = area.x + area.halfWidth;
              this.y = area.y + area.halfHeight;
              break;
            default:
              this.x = area.x;
              this.y = area.y;
          }
        }
      },
      {
        key: "getPositionArea",
        value: function() {
          return {
            x: Math.random() * (this.config.c.w / 2),
            y: Math.random() * (this.config.c.h / 2),
            halfWidth: this.config.c.w / 2,
            halfHeight: this.config.c.h / 2
          };
        }
      },
      {
        key: "getRandomInRange",
        value: function(range) {
          return range.min === range.max ? range.min : Math.random() * (range.max - range.min) + range.min;
        }
      },
      {
        key: "getRandomDirection",
        value: function() {
          return Math.random() > 0.5 ? 1 : -1;
        }
      },
      {
        key: "getRandomShape",
        value: function() {
          return this.config.shapes[Math.floor(Math.random() * this.config.shapes.length)];
        }
      },
      {
        key: "animate",
        value: function(ctx, maxWidth, maxHeight) {
          if (this.config.size.pulse) {
            this.size += this.config.size.pulse * this.direction;
            if (this.size > this.config.size.max || this.size < this.config.size.min) this.direction *= -1;
            this.size = Math.abs(this.size);
          }
          this.x += this.vx;
          this.y += this.vy;

          // 边界反弹逻辑
          if (this.x < 0 || this.x > maxWidth) {
            this.vx *= -1;
            this.x = Math.max(0, Math.min(this.x, maxWidth));
          }
          if (this.y < 0 || this.y > maxHeight) {
            this.vy *= -1;
            this.y = Math.max(0, Math.min(this.y, maxHeight));
          }

          this.drawShape(ctx);
        }
      },
      {
        key: "drawShape",
        value: function(ctx) {
          ctx.beginPath();
          ctx.globalCompositeOperation = this.config.blending;

          var gradient = ctx.createRadialGradient(
            this.x, this.y, 1, 
            this.x, this.y, this.size
          );
          gradient.addColorStop(0, this.getRGBA(this.config.opacity.center));
          gradient.addColorStop(1, this.getRGBA(this.config.opacity.edge));
          ctx.fillStyle = gradient;

          var radius = this.size / 2;
          switch (this.shape) {
            case "c":
              ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
              break;
            case "s":
              ctx.rect(this.x - radius, this.y - radius, this.size, this.size);
              break;
            case "t":
              var height = radius * Math.tan(Math.PI / 6);
              ctx.moveTo(this.x - radius, this.y + height);
              ctx.lineTo(this.x + radius, this.y + height);
              ctx.lineTo(this.x, this.y - 2 * height);
              break;
          }
          ctx.closePath();
          ctx.fill();
        }
      },
      {
        key: "getRGBA",
        value: function(opacity) {
          return "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + opacity + ")";
        }
      }
    ]);

    return Particle;
  })();

  // 主类
  var FinisherHeader = (function() {
    function FinisherHeader(config) {
      _classCallCheck(this, FinisherHeader);

      this.config = Object.assign({
        className: "finisher-header",
        skew: 0
      }, config);

      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.canvas.id = "finisher-canvas";
      this.attachToDOM();
      this.initialize();
      this.setupResizeHandler();
      window.requestAnimationFrame(this.animate.bind(this));
    }

    _createClass(FinisherHeader, [
      {
        key: "initialize",
        value: function() {
          this.config.c = { 
            w: this.canvas.clientWidth, 
            h: this.canvas.clientHeight 
          };
          this.bgColor = parseColor(this.config.colors.background);
          this.particles = [];
          this.resizeCanvas();
          this.generateParticles();
        }
      },
      {
        key: "attachToDOM",
        value: function() {
          var container = document.querySelector("." + this.config.className);
          if (!container) throw new Error("Container element not found");
          
          // 强制容器高度为视口高度
          container.style.position = "relative";
          container.style.width = "100%";
          container.style.height = "100vh";
          
          // 设置 Canvas 样式
          this.canvas.style.position = "absolute";
          this.canvas.style.top = "0";
          this.canvas.style.left = "0";
          this.canvas.style.width = "100%";
          this.canvas.style.height = "100%";
          container.appendChild(this.canvas);
        }
      },
      {
        key: "resizeCanvas",
        value: function() {
          var container = document.querySelector("." + this.config.className);
          this.config.c = { 
            w: container.offsetWidth, 
            h: container.offsetHeight 
          };
          this.canvas.width = this.config.c.w;
          this.canvas.height = this.config.c.h;
        }
      },
      {
        key: "generateParticles",
        value: function() {
          this.particles = [];
          var colorIndex = 0;
          var particleCount = window.innerWidth < 600 ? Math.round(this.config.count / 2) : this.config.count;
          
          for (var i = 0; i < particleCount; i++) {
            var positionType = i % 4;
            var color = this.config.colors.particles[colorIndex];
            this.particles.push(new Particle(color, positionType, this.config));
            colorIndex = (colorIndex + 1) % this.config.colors.particles.length;
          }
        }
      },
      {
        key: "animate",
        value: function() {
          window.requestAnimationFrame(this.animate.bind(this));
          this.ctx.clearRect(0, 0, this.config.c.w, this.config.c.h);
          this.ctx.fillStyle = "rgba(" + this.bgColor.r + "," + this.bgColor.g + "," + this.bgColor.b + ",1)";
          this.ctx.fillRect(0, 0, this.config.c.w, this.config.c.h);
          
          for (var i = 0; i < this.particles.length; i++) {
            this.particles[i].animate(this.ctx, this.config.c.w, this.config.c.h);
          }
        }
      }
    ]);

    return FinisherHeader;
  })();

  window.FinisherHeader = FinisherHeader;
}(window);